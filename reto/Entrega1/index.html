<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
<script type="module">
    /*  import * as THREE from 'three'*/
    import * as THREE from 'https://cdn.skypack.dev/three@0.134.0';
    import {OrbitControls} from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/controls/OrbitControls';
    import Stats from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/libs/stats.module';
    import {OBJLoader} from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/loaders/OBJLoader.js';
    import {GLTFLoader} from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/loaders/GLTFLoader.js';
    import { EXRLoader } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/loaders/EXRLoader.js';

    const objLoader = new OBJLoader();
    const gltfLoader = new GLTFLoader();


    "use strict";

    let renderer, scene, camera, orbitControls, model, stats, gui;

    function init(event) {
        // RENDERER ENGINE
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
        renderer.setClearColor(new THREE.Color(0, 0, 0));
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);



        scene = new THREE.Scene();

        // MODELS
        const scenary = new Scenary();
        model = new SportsCar2(0, 0);

        // SCENE
        new EXRLoader()
            .setPath('assets/textures/')
            .load('4k.exr', function (texture) {

                texture.mapping = THREE.EquirectangularReflectionMapping;

                scene.background = texture;
                scene.environment = texture;

                render();

                // model

            });

        // SCENE GRAPH
        scene.add(scenary);
        scene.add(model);

        // CAMERA (PERSPECTIVE)
        const fov = 60;    // Field ov view
        const aspect = window.innerWidth / window.innerHeight;
        const near = 0.01;
        const far = 10000.0;
        camera = new Camera(fov, aspect, near, far);
        camera.position.set(-100, 100, 300);


        // CAMERA CONTROLS
        orbitControls = new OrbitControls(camera, renderer.domElement);
        //orbitControls.target = model.position;
        orbitControls.update();

        // SETUP STATS
        stats = new Stats();
        stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
        document.body.appendChild(stats.dom);

        // GUI
        gui = new dat.GUI();
        // SCENE-MENU
        const guiSceneMenu = gui.addFolder("Scene Menu");
        guiSceneMenu.add(scenary.axes, "visible").setValue(scenary.axes.visible).name("World Axes").listen().onChange(function (value) {
            scenary.axes.setVisible(value);
        });
        guiSceneMenu.open();


        // MODEL-MENU
        const guiCameraMenu = gui.addFolder("Camera Menu");
        // GUI-Model

        guiCameraMenu.add(camera, "viewNum").min(0).max(5).step(1).setValue(camera.viewNum).name("Change view").listen().onChange(function (value) {
            camera.updateView();
        });

        // DRAW SCENE IN A RENDER LOOP (ANIMATION)
        renderLoop();
    }

    function renderLoop() {
        stats.begin();
        renderer.render(scene, camera); // DRAW THE SCENE GRAPH
        updateScene();
        stats.end();
        requestAnimationFrame(renderLoop);
    }

    function updateScene() {
        if (model && model.animate) {
            model.move(0.2, 90)
            //model.rotation.y = model.rotation.y + 0.01;
        }
        if (camera && camera.viewNum == 0) {
            camera.orbitControls.update();
        }
        if (camera && camera.viewNum == 5) {
            camera.setInModelView(model);
        }
    }

    // EVENT LISTENERS & HANDLERS
    document.addEventListener("DOMContentLoaded", init);

    window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }, false);

    class Camera extends THREE.PerspectiveCamera {
        constructor(
            fov = 60,
            aspect = window.innerWidth / window.innerHeight,
            near = 0.01,
            far = 10000.0,
        ) {
            super(fov, aspect, near, far);

            this.viewNum = 0;

            // orbit controls
            this.orbitControls = new OrbitControls(
                this,
                renderer.domElement
            );
            this.orbitControls.update();

        }

        setPerspectiveView() {
            this.position.set(-100, 100, 300);
            this.orbitControls.target = new THREE.Vector3(0, 0, 0);
            this.up.set(0, 1, 0);
            this.orbitControls.update();
        }

        setTopView() {
            this.position.set(0, 300, 0);
            this.orbitControls.target = new THREE.Vector3(0, 0, 0);
            this.up.set(-1, 0, 0);
            this.orbitControls.update();
        }

        setFrontView() {
            this.position.set(0, 1.8, 300);
            this.orbitControls.target = new THREE.Vector3(0, 0, 0);
            this.up.set(0, 1, 0);
            this.orbitControls.update();
        }

        setSideView() {
            this.position.set(300, 1.8, 0);
            this.orbitControls.target = new THREE.Vector3(0, 0, 0);
            this.up.set(0, 1, 0);
            this.orbitControls.update();
        }

        setInModelView(model) {
            this.position.set(
                model.position.x - 0.5,
                model.position.y + 1.7,
                model.position.z
            );
            // Camera follows the model + 3 units
            this.orbitControls.target = new THREE.Vector3(
                model.position.x + 5,
                model.position.y + 1,
                model.position.z - 60
            );
            this.up.set(0, 1, 0);
            this.orbitControls.update();
        }

        setAutoRotate(value, speed = 0.5) {
            this.orbitControls.autoRotate = value;
            this.orbitControls.autoRotateSpeed = speed;
            this.orbitControls.update();
        }

        updateView() {
            this.setAutoRotate(false);
            switch (this.viewNum) {
                case 0:
                    this.setAutoRotate(true);
                    break;
                case 1:
                    this.setPerspectiveView();
                    break;
                case 2:
                    this.setTopView();
                    break;
                case 3:
                    this.setFrontView();
                    break;
                case 4:
                    this.setSideView();
                    break;
                case 5:
                    this.setInModelView(model);
                    break;
            }
        }

    }

    class Axes extends THREE.AxesHelper {
        constructor(size = 10, visible = true) {
            super(size);
            this.size = size;
            this.visible = visible;
            this.position.set(0, 1, 0);
        }

        setVisible(value) {
            this.visible = value;
        }
    }

    class SportsCar extends THREE.Group {
        constructor(objFileName = "./assets/obj/Car1.obj") {
            super();
            this.color = 0xcc0000;
            this.wireColor = 0xffffff;
            this.doubleSide = false;
            this.rotate = false;
            this.objFileName = objFileName;
            this.loadOBJModel(objFileName);
        }

        loadOBJModel(objFileName) {
            // instantiate a loader
            // load a resource
            model = this;
            objLoader.load(objFileName,
                // called when resource is loaded
                function (object) {
                    // SOLID
                    object.traverse(function (child) {
                        if (child.isMesh) {
                            child.material = new THREE.MeshBasicMaterial({color: model.color});
                        }
                    });
                    model.solid = object;
                    // WIRE
                    model.wire = object.clone();
                    model.wire.traverse(function (child) {
                        if (child.isMesh) {
                            child.material = new THREE.MeshBasicMaterial({wireframe: true, color: model.wireColor});
                        }
                    });
                    /*          model.rotation.y = Math.PI;
                              model.scale.set(2, 2, 2);*/
                    // CHILDREN
                    model.add(model.solid);
                    model.add(model.wire);
                    scene.add(model);
                    model.setOnFloor();

                    // MODEL-MENU
                    const guiModelMenu = gui.addFolder("Model Menu");
                    // GUI-Model
                    guiModelMenu.add(model, "visible").setValue(model.visible).name("Visible").listen().onChange(function (value) {

                    });
                    guiModelMenu.add(model.solid, "visible").setValue(model.solid.visible).name("Wireframe").listen().onChange(function (value) {

                    });
                    guiModelMenu.add(model, "doubleSide").setValue(model.doubleSide).name("Double Side").listen().onChange(function (value) {
                        model.setDoubleSide(value);
                    });
                    guiModelMenu.addColor(model, "color").name("Color").setValue(model.color).listen().onChange(function (value) {
                        model.setColor(value);
                    });
                    guiModelMenu.addColor(model, "wireColor").name("Wire Color").setValue(model.wireColor).listen().onChange(function (value) {
                        model.setWireColor(value);
                    });
                    guiModelMenu.add(model, "animate").setValue(model.animate).name("Animate").listen().onChange(function (value) {

                    });
                },
                // called when loading is in progresses
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                // called when loading has errors
                function (error) {
                    console.log('An error happened' + error);
                }
            );
        }

        setColor(hexColor) {
            this.color = hexColor;
            this.solid.traverse(function (child) {
                if (child.isMesh) {
                    child.material.color.setHex(hexColor);
                }
            });
        }

        setWireColor(hexColor) {
            this.wireColor = hexColor;
            this.wire.traverse(function (child) {
                if (child.isMesh) {
                    child.material.color.setHex(hexColor);
                }
            });
        }

        setDoubleSide(value) {
            this.doubleSide = value;
            this.solid.traverse(function (child) {
                if (child.isMesh) {
                    if (value) {
                        child.material.side = THREE.DoubleSide;
                    } else {
                        child.material.side = THREE.FrontSide;
                    }
                }
            });
        }

        setOnFloor() {
            const bBox = new THREE.Box3();
            bBox.setFromObject(this.solid);
            this.position.y = -bBox.min.y;
        }
    }

    class SportsCar2 extends SportsCar {
        constructor(x, z) {
            super();
            this.x = x;
            this.z = z;
            this.animate = false;
            this.position.set(x, 0, z);
        }

        move(x, y) {
            let direction;
            if (this.position.x  < x) {
                direction =  90 * (Math.PI / 180)
            } else {
                direction = 0;
            }

            this.position.x = x;
            this.position.y = y;
            this.rotation.set(0, direction, 0);
        }
    }

    class Streets extends THREE.Group {
        constructor(gltfFileName = "./assets/gltf/street.glb") {
            super();
            this.color = 0xcc0000;
            this.wireColor = 0xffffff;
            this.doubleSide = false;
            this.rotate = false;
            this.gltfFileName = gltfFileName;
            this.loadGLTFModel(gltfFileName);
        }

        loadGLTFModel(gltfFileName) {
            // instantiate a loader
            // load a resource
            model = this;
            gltfLoader.load(gltfFileName,
                // called when resource is loaded
                function (gltf) {
                    // SOLID
                    gltf.scene.position.y = -0.5;
                    scene.add(gltf.scene);


                },
                // called when loading is in progresses
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                // called when loading has errors
                function (error) {
                    console.log('An error happened' + error);
                }
            );
        }
    }

    class Scenary extends THREE.Group {
        constructor(size = 1000) {
            super();
            this.axes = new Axes(size);
            this.streets = new Streets();

            // CHILDREN
            this.add(this.axes);
            this.add(this.streets)

        }
    }

    class TrafficLight extends THREE.Group {
        constructor(size = 1000) {
            super();
            this.axes = new Axes(size);
            this.streets = new Streets();

            // CHILDREN
            this.add(this.axes);
            this.add(this.streets)

        }
    }
</script>
</body>
</html>